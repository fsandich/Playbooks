---
- name: Llamada MTLS usando .pfx en un solo play
  hosts: localhost
  gather_facts: false
  vars:
    api_url: "https://tu-endpoint/alguna/ruta"
    workdir: "/tmp/mtls_cert"        # directorio temporal
    pfx_src: "files/certificado.pfx" # ruta en tu repo Ansible
    pfx_dest: "{{ workdir }}/certificado.pfx"
    pfx_password: "{{ vault_pfx_password }}"  # desde Vault

    client_key_enc: "{{ workdir }}/client-encrypted.key"
    client_key: "{{ workdir }}/client.key"
    client_crt: "{{ workdir }}/client.crt"

    # si usas CA propia:
    ca_cert_path: "/etc/pki/ca-trust/source/anchors/mi-ca.pem"

    request_body:
      perfil: "stagging"
      Aplicacion: "RMF.Client"
      Certificado: "1b0000001276...."

  tasks:
    - name: Crear directorio temporal
      ansible.builtin.file:
        path: "{{ workdir }}"
        state: directory
        mode: "0700"

    - name: Copiar .pfx al host (localhost)
      ansible.builtin.copy:
        src: "{{ pfx_src }}"
        dest: "{{ pfx_dest }}"
        mode: "0600"

    - name: Extraer clave privada cifrada desde .pfx
      ansible.builtin.command: >
        openssl pkcs12 -in {{ pfx_dest }}
        -nocerts
        -out {{ client_key_enc }}
        -passin pass:{{ pfx_password }}
        -passout pass:{{ pfx_password }}
      args:
        creates: "{{ client_key_enc }}"

    - name: Quitar passphrase y generar client.key
      ansible.builtin.command: >
        openssl rsa
        -in {{ client_key_enc }}
        -out {{ client_key }}
        -passin pass:{{ pfx_password }}
      args:
        creates: "{{ client_key }}"

    - name: Extraer certificado público client.crt desde .pfx
      ansible.builtin.command: >
        openssl pkcs12 -in {{ pfx_dest }}
        -clcerts -nokeys
        -out {{ client_crt }}
        -passin pass:{{ pfx_password }}
      args:
        creates: "{{ client_crt }}"

    - name: Llamada MTLS con uri usando cert/key generados
      ansible.builtin.uri:
        url: "{{ api_url }}"
        method: POST
        body: "{{ request_body | to_nice_json }}"
        body_format: json
        client_cert: "{{ client_crt }}"
        client_key: "{{ client_key }}"
        ca_path: "{{ ca_cert_path }}"   # o quítalo si usas CA pública
        validate_certs: true
        return_content: true
        headers:
          Content-Type: "application/json"
      register: mtls_response

    - debug:
        var: mtls_response

    - name: Limpiar archivos temporales (opcional pero recomendable)
      ansible.builtin.file:
        path: "{{ workdir }}"
        state: absent

---
- name: Verificar que el CA bundle exista
  ansible.builtin.stat:
    path: "{{ ca_bundle_path }}"
  register: ca_stat


- name: Llamar al API para obtener token
  ansible.builtin.uri:
    url: "https://bacremesasdesa.corp.redbac.com/gateway/auth/v1/aplicacion"
    method: POST
    headers:
        Content-Type: "application/json"
    body_format: json
    body:
        Perfil: "Staging"
        Aplicacion: "RMP.CLIENT.ANSIBLE"
        Certificado: "1b000013786aabdc6326c4bb32000000001378"
    return_content: yes
    status_code: 200
    timeout: 60
    validate_certs: true
    ca_path: "{{ ca_bundle_path }}
    register: api_response

- name: Validar estructura de respuesta
  ansible.builtin.assert:
    that:
      - "{{ api_response.json is defined }}"
      - "{{ api_response.json.contenido is defined }}"
      - "{{ api_response.json.contenido.token is defined }}"
    fail_msg: >-
      La respuesta no contiene 'contenido.token'. Respuesta: {{ api_response.content | default(api_response, true) }}
  no_log: true


- name: Guardar token
  ansible.builtin.set_fact:
    mi_token: "{{ api_response.json.contenido.token }}"
  no_log: true

- name: Confirmación
  ansible.builtin.debug:
    msg: "Token obtenido correctamente."



    mkdir -p certs

# 1) Llave privada (quitar passphrase al final)
openssl pkcs12 -in RMF.CLIENT.ANSIBLE.pfx -nocerts -out certs/RMP.CLIENT.ANSIBLE.key
# Si pide pass del PFX, ingrésala. Luego dejar la key sin pass:
openssl pkey -in certs/RMP.CLIENT.ANSIBLE.key -out certs/RMP.CLIENT.ANSIBLE.key

# 2) Certificado de cliente
openssl pkcs12 -in RMF.CLIENT.ANSIBLE.pfx -clcerts -nokeys -out certs/RMP.CLIENT.ANSIBLE.crt

# 3) Cadena/CA del servidor (si viene en el PFX)
openssl pkcs12 -in RMF.CLIENT.ANSIBLE.pfx -cacerts -nokeys -out certs/ca_chain.pem


dos2unix certs/RMP.CLIENT.ANSIBLE.key certs/RMP.CLIENT.ANSIBLE.crt certs/ca_chain.pem 2>/dev/null || true
chmod 600 certs/RMP.CLIENT.ANSIBLE.key
chmod 644 certs/RMP.CLIENT.ANSIBLE.crt certs/ca_chain.pem


# Cert y key deben “hacer pareja”
openssl x509 -noout -modulus -in certs/RMP.CLIENT.ANSIBLE.crt | openssl md5
openssl pkey  -noout -modulus -in certs/RMP.CLIENT.ANSIBLE.key | openssl md5
# Hashes IGUALES

# Serial del cert (debe coincidir con el del body)
openssl x509 -in certs/RMP.CLIENT.ANSIBLE.crt -noout -serial
# Esperado: 1b000013786aabdc6326c4bb32000000001378


unable to load key
8516857984:error:09FFF06C:PEM routines:CRYPTO_internal:no start line:/AppleInternal/Library/BuildRoots/4~CG4rugD0hu_MMyfOtGzXkKREnKN0qX1CS-H2E2k/Library/Caches/com.apple.xbs/Sources/libressl/libressl-3.3/crypto/pem/pem_lib.c:694:Expecting: ANY PRIVATE KEY
